数组的声明

```
var a [10]int
b := [2] string {
    "hello",
    "world"
}
var c [3]int = [3]int{1, 2, 3}
d := [...]int{1, 2, 3}
```

对于数组而言，长度属于类型的一部分

```
q := [3]int{1, 2, 3}
q = [4]int{1, 2, 3, 4} //compile error
```

两个数组可比较的条件是：1）数组元素类型和数组长度相同，2）数组元素类型是可比较的。相等的条件是每个对应的元素都相等

```
a := [2]int{1, 2}
b := [...]int{1, 2}
c := [2]int{1, 3}
d := [3]int{1, 2}
fmt.Println(a == b, a == c, a == d) //"true false false"
```

和其他大部分语言不同，当数组作为函数参数时，会拷贝传值，这意味着性能损耗且函数无法对数组的内容进行修改。为了解决这个问题，参数类型可以是数组的指针。但这并不是最灵活的解决方案，因为此函数只能接收固定个数数组的指针类型

```
//此函数不能接受*[16]byte类型的指针
func zero(ptr *[32]byte) {
	*ptr = [32]byte{}
}
```

切片和数组的声明区别在于[ ]中是否带数字。使用**s[i:j]**创建的切片所引用的数组范围是**i...j-1**，因此必须有**0 <= i <= cap(s)**。若**i**缺省，则默认为0，若**j**缺省，默认为**len(s)**。注意这里**s**可能是数组或是切片

```
var a [10] int

s0 := a[0:3]
var s1 [] int = a[3:]
```


切片只是数组的引用，修改一方的数据会影响另一方的值。以下代码相当于创建一个数组并基于数据创建切片

```
s := [] bool {
    true,
    true,
    false
}
```

数组的长度和容量是相等的。切片的长度取决于声明时的大小，容量 = 数组的容量 - 切片相对数组的起始位置

```
var a [10]int
s0 := a[0:5]
s1 := a[5:]

lenA = len(a)       //10
capA = cap(a)       //10    

lenS = len(s0)       //5
capS = cap(s0)       //10
```

切片只是数组的引用，修改切片的内容，或是往切片追加数据，会影响数组本身。切片类型作为函数参数用于修改数组内容，是相对使用数组指针更灵活的解决方法。

```

```
append函数用于对切片追加内容，可以同时添加多个元素，甚至添加切片。追加切片**s**时会追加**len(s)**个元素而非**cap(s)**

```
var x []int
x = append(x, 1)
x = append(x, 2, 3)
x = append(x, x...)

fmt.Println(x)	//"[1 2 3 1 2 3]"
```

当切片的容量不足以存储追加的数据时，go会重新申请一个新的数组，进行内存拷贝并将结果返回。因此使用append或其他可能改变切片长度或容量的操作时，需要将返回值赋值给原切片

```
var x []int
x = append(x, 1)
```

切片之间是不可比较的，若要对切片内容进行比较，需要手动实现。唯一例外的是[]byte类型的切片

```
func equal(x, y []string) bool {
	if len(x) != len(y) {
		return false
	}
	for i := range x {
		if x[i] != y[i] {
			return false
		}
	}
	return true
}
```

切片可以和nil比较，一个值为nil的切片没有与之关联的数组，len和cap的值为0。反之不成立，len和cap为0的切片不是一定为nil。因此，若要判断一个切片是否为空，应该使用len(s) == 0而不是s == nil

```
var s []int			//len(s) == 0, s == nil
s = []int(nil) 		//len(s) == 0, s == nil
s = []int{}			//len(s) == 0, s != nil
```

动态创建切片

```
a := make([]int, 5)     //len(a) = 5, cap(a) = 5
b := make([]int, 0, 5)  //len(b) = 0, cap(b) = 5
```


结构体数组／切片

```
//Vertex是预定义的结构体
a := [] Vertex {
	{0, 1},
	{1, 2},    //,避免自动插入分号
}

//临时定义一个结构体
s := []struct {
	i int
	b bool
}{
	{2, true},
	{3, false},
	{5, true},
	{7, true},
	{11, false},
	{13, true},
}
```


